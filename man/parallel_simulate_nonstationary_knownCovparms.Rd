% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parallel.R
\name{parallel_simulate_nonstationary_knownCovparms}
\alias{parallel_simulate_nonstationary_knownCovparms}
\title{Simulation on nonstationary cases}
\usage{
parallel_simulate_nonstationary_knownCovparms(
  cand.m,
  nsim,
  n,
  d,
  covmodel = cov_matern_ns_bruteforce,
  sigma,
  smoothness,
  kernel,
  method.locs = "random",
  method.modify = NULL,
  pivot = FALSE,
  tol = .Machine$double.eps,
  ncores = NULL
)
}
\arguments{
\item{cand.m}{A numeric vector of candidates of the size of conditioning sets (m)}

\item{nsim}{A number of repeated simualtions for each case}

\item{n}{A number of locations}

\item{d}{A dimension of domain}

\item{covmodel}{A covariance function}

\item{sigma}{numeric function for spatially varying standard deviation \eqn{\sigma( loc )}}

\item{smoothness}{A numeric function for spatially varying smoothness \eqn{\nu( loc )}}

\item{kernel}{A matrix-valued function for spatially varying (local) geometric anisotropy \eqn{\Sigma( loc )}}

\item{method.locs}{random or grid}

\item{method.modify}{An argument specifying a correction method for the cholesky factorization of a covariance matrix. At \code{NULL} by default.
If correction is \code{NULL}, then the built-in R function \code{chol} is used.
If correction is \code{"qr"}, then the built-in R function \code{qr} is used.
If correction is \code{"diag"}, then \code{C + diag(tol, n)} is used instead of a covariance matrix \code{C}.
Correction methods \code{"type-I"}, \code{"type-II"}, \code{"eigen-I"}, \code{"eigen-II"}, \code{"GMW81"}, and \code{"SE99"} are refered to Fang and O'leary (2008).
Correction method \code{"nearPD"} use a built-in function nearPD() in the R package Matrix.}

\item{pivot}{Logical indicating if pivoting is to be used when factorizing a covariance matrix. At \code{FALSE} by default}

\item{tol}{Numerical tolerance. At \code{.Machine$double.eps} by default}

\item{ncores}{A number of cores for parallel computing}
}
\value{
list
}
\description{
Simulation on nonstationary cases
}
\examples{
### comparison ###

locs <- matrix(runif(100), 50, 2)

kernel <- function(loc) {
  
  d         <- length(loc)
  
  a         <- function(loc) 10 * 10 # please use your own a function for the first coordinate
  b         <- function(loc) 10 # please use your own a function for the second coordinate
  angle     <- function(loc) 0 # please use your own spatially varying rotation angle
  
  eta       <- angle(loc)
  rot.mat   <- matrix(c(cos(eta), sin(eta), -sin(eta), cos(eta)), nrow = d, ncol = d, byrow = TRUE)
  
  range     <- c(a(loc)^(-2), b(loc)^(-2))
  
  return( t(rot.mat) \%*\% diag(range, nrow = d) \%*\% rot.mat )
}

sigma <- function(loc) determinant(kernel(loc), logarithm = FALSE)[[1]][1]^0.25

smoothness <- function(loc) 0.5

mat1 <- cov_matern_ns_bruteforce(locs1 = locs, locs2 = NULL, 
                                 sigma = sigma, smoothness = smoothness, kernel = kernel)
mat2 <- cov_expo_aniso(locs = locs, covparms = c(1, 0.1), a = c(10, 1))

sqrt(sum((mat1 - mat2)^2))

### sim 1: smoothness ###

kernel <- function(loc) {
  
  d         <- length(loc)
  
  a         <- function(loc) 10
  b         <- function(loc) 10
  angle     <- function(loc) 0
  
  eta       <- angle(loc)
  rot.mat   <- matrix(c(cos(eta), sin(eta), -sin(eta), cos(eta)), nrow = d, ncol = d, byrow = TRUE)
  
  range     <- c(a(loc)^(-2), b(loc)^(-2))
  
  return( t(rot.mat) \%*\% diag(range, nrow = d) \%*\% rot.mat )
}

sigma <- function(loc) determinant(kernel(loc), logarithm = FALSE)[[1]][1]^0.25

smoothness <- function(loc) 0.2 + 1.3 * loc[1]

\dontrun{
 out <- parallel_simulate_nonstationary_knownCovparms(cand.m = c(10, 20), 
                                                      nsim = 2, n = 10^2, d = 2, 
                                                      covmodel = cov_matern_ns_bruteforce, 
                                                      sigma = sigma, smoothness = smoothness, 
                                                      kernel = kernel)
 out$kldiv
}


### sim 2: range ###

kernel <- function(loc) {
  
  d         <- length(loc)
  
  a         <- function(loc) 10 * (1 + 10 * loc[1])
  b         <- function(loc) 10 * (1 + 10 * loc[1]) 
  angle     <- function(loc) 0 
  
  eta       <- angle(loc)
  rot.mat   <- matrix(c(cos(eta), sin(eta), -sin(eta), cos(eta)), nrow = d, ncol = d, byrow = TRUE)
  
  range     <- c(a(loc)^(-2), b(loc)^(-2))
  
  return( t(rot.mat) \%*\% diag(range, nrow = d) \%*\% rot.mat )
}

sigma <- function(loc) determinant(kernel(loc), logarithm = FALSE)[[1]][1]^0.25

smoothness <- function(loc) 0.5

\dontrun{
 out <- parallel_simulate_nonstationary_knownCovparms(cand.m = c(10, 20), 
                                                      nsim = 2, n = 10^2, d = 2, 
                                                      covmodel = cov_matern_ns_bruteforce, 
                                                      sigma = sigma, smoothness = smoothness, 
                                                      kernel = kernel)
 out$kldiv
}


### sim 2 - 1: range ###

kernel <- function(loc) {
  
  d         <- length(loc)
  
  a         <- function(loc) 10/(0.1 + 0.9 * loc[1]) 
  b         <- function(loc) 10/(0.1 + 0.9 * loc[1]) 
  angle     <- function(loc) 0 
  
  eta       <- angle(loc)
  rot.mat   <- matrix(c(cos(eta), sin(eta), -sin(eta), cos(eta)), nrow = d, ncol = d, byrow = TRUE)
  
  range     <- c(a(loc)^(-2), b(loc)^(-2))
  
  return( t(rot.mat) \%*\% diag(range, nrow = d) \%*\% rot.mat )
}

sigma <- function(loc) determinant(kernel(loc), logarithm = FALSE)[[1]][1]^0.25

smoothness <- function(loc) 0.5

\dontrun{
 out <- parallel_simulate_nonstationary_knownCovparms(cand.m = c(10, 20), 
                                                      nsim = 2, n = 10^2, d = 2, 
                                                      covmodel = cov_matern_ns_bruteforce, 
                                                      sigma = sigma, smoothness = smoothness, 
                                                      kernel = kernel)
 out$kldiv
}


### sim 3: anisotropy ###

kernel <- function(loc) {
  
  d         <- length(loc)
  
  a         <- function(loc) 10 * (1 + 10 * loc[1]) 
  b         <- function(loc) 10 
  angle     <- function(loc) 0 
  
  eta       <- angle(loc)
  rot.mat   <- matrix(c(cos(eta), sin(eta), -sin(eta), cos(eta)), nrow = d, ncol = d, byrow = TRUE)
  
  range     <- c(a(loc)^(-2), b(loc)^(-2))
  
  return( t(rot.mat) \%*\% diag(range, nrow = d) \%*\% rot.mat )
}

sigma <- function(loc) determinant(kernel(loc), logarithm = FALSE)[[1]][1]^0.25

smoothness <- function(loc) 0.5

\dontrun{
 out <- parallel_simulate_nonstationary_knownCovparms(cand.m = c(10, 20), 
                                                      nsim = 2, n = 10^2, d = 2, 
                                                      covmodel = cov_matern_ns_bruteforce, 
                                                      sigma = sigma, smoothness = smoothness, 
                                                      kernel = kernel)
 out$kldiv
}


### sim 4: rotation ###

kernel <- function(loc) {
  
  d         <- length(loc)
  
  a         <- function(loc) 10 * 10 
  b         <- function(loc) 10 
  angle     <- function(loc) pi * loc[1] / 2
  
  eta       <- angle(loc)
  rot.mat   <- matrix(c(cos(eta), sin(eta), -sin(eta), cos(eta)), nrow = d, ncol = d, byrow = TRUE)
  
  range     <- c(a(loc)^(-2), b(loc)^(-2))
  
  return( t(rot.mat) \%*\% diag(range, nrow = d) \%*\% rot.mat )
}

sigma <- function(loc) determinant(kernel(loc), logarithm = FALSE)[[1]][1]^0.25

smoothness <- function(loc) 0.5

\dontrun{
 out <- parallel_simulate_nonstationary_knownCovparms(cand.m = c(10, 20), 
                                                      nsim = 2, n = 10^2, d = 2, 
                                                      covmodel = cov_matern_ns_bruteforce, 
                                                      sigma = sigma, smoothness = smoothness, 
                                                      kernel = kernel)
 out$kldiv
}
}
