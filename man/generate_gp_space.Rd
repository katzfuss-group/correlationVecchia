% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/process.R
\name{generate_gp_space}
\alias{generate_gp_space}
\title{Generating realizations of spatial mean-zero Gaussian Process (GP) using a user-defined covariance function}
\usage{
generate_gp_space(
  nsim,
  n,
  d,
  p,
  method.locs,
  covmodel,
  method.modify = NULL,
  pivot = FALSE,
  tol = .Machine$double.eps,
  verbose = TRUE,
  ...
)
}
\arguments{
\item{nsim}{A number of realizations of the GP}

\item{n}{A number of locations}

\item{d}{A dimension of domain}

\item{p}{A number of GPs}

\item{method.locs}{random, overlap, or grid}

\item{covmodel}{A covariance function}

\item{method.modify}{An argument specifying a correction method for the cholesky factorization of a covariance matrix. At \code{NULL} by default.
If correction is \code{NULL}, then the built-in R function \code{chol} is used.
If correction is \code{"qr"}, then the built-in R function \code{qr} is used.
If correction is \code{"diag"}, then \code{C + diag(tol, n)} is used instead of a covariance matrix \code{C}.
Correction methods \code{"type-I"}, \code{"type-II"}, \code{"eigen-I"}, \code{"eigen-II"}, \code{"GMW81"}, and \code{"SE99"} are refered to Fang and O'leary (2008).
Correction method \code{"nearPD"} use a built-in function nearPD() in the R package Matrix.}

\item{pivot}{Logical indicating if pivoting is to be used when factorizing a covariance matrix.  At \code{FALSE} by default}

\item{tol}{Numerical tolerance. At \code{.Machine$double.eps} by default}

\item{verbose}{Logical at \code{TRUE} by default. If verbose is \code{TRUE}, then this function prints out all messages}

\item{...}{Covariance parameters}
}
\value{
\code{generate_gp} returns
\itemize{
\item{\code{nsim}: } A number of realizations of the GP
\item{\code{n}: } An actual number of locations
\item{\code{d}: } A dimension of domain
\item{\code{p}: } A number of GPs
\item{\code{method.locs}: } The argument method.locs
\item{\code{method.modify}: } The argument method.modify
\item{\code{pivot}: } The argument pivot
\item{\code{tol}: } The argument tol
\item{\code{sim}: } Simulation results
}
}
\description{
Generating realizations of spatial mean-zero Gaussian Process (GP) using a user-defined covariance function
}
\examples{
par(mfrow = c(2, 3))

out <- generate_gp_space(nsim = 2, n = 19, d = 2, p = 1, 
                         method.locs = 'random', covmodel = cov_expo_iso, 
                         method.modify = NULL, pivot = FALSE, 
                         tol = .Machine$double.eps, 
                         covparms = c(1, 0.1))
plot(as.data.frame(out$sim$sim1$locs), col = 'red', lwd = 2, 
     main = 'Random locs for univariate GP')

out <- generate_gp_space(nsim = 2, n = 19, d = 2, p = 1, 
                         method.locs = 'overlap', covmodel = cov_expo_iso, 
                         method.modify = NULL, pivot = FALSE, 
                         tol = .Machine$double.eps, 
                         covparms = c(1, 0.1))
plot(as.data.frame(out$sim$sim1$locs), col = 'red', lwd = 2, 
     main = 'Overlapped locs for univariate GP')

out <- generate_gp_space(nsim = 2, n = 19, d = 2, p = 1, 
                         method.locs = 'grid', covmodel = cov_expo_iso, 
                         method.modify = NULL, pivot = FALSE, 
                         tol = .Machine$double.eps, 
                         covparms = c(1, 0.1))
plot(as.data.frame(out$sim$sim1$locs), col = 'red', lwd = 2, 
     main = 'Grid locs for univariate GP')

out <- generate_gp_space(nsim = 2, n = 19, d = 2, p = 2, 
                         method.locs = 'random', covmodel = cov_bivariate_flexMatern, 
                         method.modify = NULL, pivot = FALSE, 
                         tol = .Machine$double.eps, 
                         sigma.mat = matrix(c(1, 0.5, 0.5, 1), 2, 2), 
                         nu.mat = matrix(0.5, 2, 2), 
                         alpha.mat = matrix(1, 2, 2))
plot(as.data.frame(out$sim$sim1$locs[[1]]), col = 'red', lwd = 2, 
     main = 'Random locs for bivariate GP')
points((as.data.frame(out$sim$sim1$locs[[2]])), col = 'blue')

out <- generate_gp_space(nsim = 2, n = 19, d = 2, p = 2, 
                         method.locs = 'overlap', covmodel = cov_bivariate_flexMatern, 
                         method.modify = NULL, pivot = FALSE, 
                         tol = .Machine$double.eps, 
                         sigma.mat = matrix(c(1, 0.5, 0.5, 1), 2, 2), 
                         nu.mat = matrix(0.5, 2, 2), 
                         alpha.mat = matrix(1, 2, 2))
plot(as.data.frame(out$sim$sim1$locs[[1]]), col = 'red', lwd = 2, 
     main = 'Overlapped locs for bivariate GP')
points((as.data.frame(out$sim$sim1$locs[[2]])), col = 'blue')

out <- generate_gp_space(nsim = 2, n = 19, d = 2, p = 2, 
                         method.locs = 'grid', covmodel = cov_bivariate_flexMatern, 
                         method.modify = NULL, pivot = FALSE, 
                         tol = .Machine$double.eps, 
                         sigma.mat = matrix(c(1, 0.5, 0.5, 1), 2, 2), 
                         nu.mat = matrix(0.5, 2, 2), 
                         alpha.mat = matrix(1, 2, 2))
plot(as.data.frame(out$sim$sim1$locs[[1]]), col = 'red', lwd = 2,
     main = 'Grid locs for bivariate GP')
points((as.data.frame(out$sim$sim1$locs[[2]])), col = 'blue')

par(mfrow = c(1, 1))
}
