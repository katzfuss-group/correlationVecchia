% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/covmodels.R
\name{cov_latentDim_biv}
\alias{cov_latentDim_biv}
\title{Isotropic exponential covariance function for bivariate Gaussian Processes using latent dimensions}
\usage{
cov_latentDim_biv(locs = NULL, locs1 = NULL, locs2 = NULL, covparms)
}
\arguments{
\item{locs}{At \code{NULL} by default. When used, it must be a list of two location matrices which is list(locs1 = locs1, locs2 = locs2)}

\item{locs1}{At \code{NULL} by default. When used, it must be a numerical matrix with \code{n1} rows and \code{d} columns. Each row of locs1 gives a point of the first set in R^d}

\item{locs2}{At \code{NULL} by default. When used, it must be a numerical matrix with \code{n2} rows and \code{d} columns. Each row of locs2 gives a point of the second set in R^d}

\item{covparms}{A numerical vector with covariance parameters. Its form must be (variance, range, latent dimension).}
}
\value{
An isotropic exponential covariance matrix with \code{n1 + n2} rows and \code{n1 + n2} columns
}
\description{
Isotropic exponential covariance function for bivariate Gaussian Processes using latent dimensions
}
\examples{
locs1 <- matrix(runif(4), 2, 2)
locs2 <- matrix(runif(6), 3, 2)
locs3 <- matrix(runif(8), 4, 2)
covparms <- c(1, 0.1, 1)

covmat1 <- cov_latentDim_biv(locs1 = locs1, locs2 = locs2,
                             covparms = covparms)
covmat2 <- cov_latentDim_triv(locs1 = locs1, locs2 = locs2, locs3 = locs3,
                              covparms = covparms)[1:5, 1:5]
covmat3 <- cov_latentDim_mulv(locs = list(locs1, locs2, locs3),
                              covparms = covparms)[1:5, 1:5]

sqrt(sum((covmat1 - covmat2)^2))
sqrt(sum((covmat1 - covmat3)^2))

crossmat1 <- cov_latentDim_mulv(locs = list(locs1, locs2, locs3),
                                covparms = covparms)[1:5, 6:9]
crossmat2 <- cov_latentDim_mulv(locs = list(locs1, locs2, locs3),
                                covparms = covparms[1:2], k = 2,
                                latent = list(cbind(rep(0, 2),
                                                    rep(0, 2)),
                                              cbind(rep(covparms[3], 3),
                                                    rep(0, 3)),
                                              cbind(rep(2 * covparms[3], 4),
                                                    rep(0, 4))))[1:5, 6:9]

sqrt(sum((crossmat1 - crossmat2)^2))
}
