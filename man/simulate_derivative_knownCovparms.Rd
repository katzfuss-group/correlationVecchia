% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/simulation.R
\name{simulate_derivative_knownCovparms}
\alias{simulate_derivative_knownCovparms}
\title{Conducting simulation on vecchia approximations for (GP, dGP/dx, dGP/dy) with known covariance parameters}
\usage{
simulate_derivative_knownCovparms(
  nsim,
  n,
  d,
  m,
  method.locs,
  method.modify = NULL,
  pivot = FALSE,
  tol = .Machine$double.eps,
  verbose = TRUE,
  covmodel,
  ...
)
}
\arguments{
\item{nsim}{A number of realizations of the GP}

\item{n}{A number of locations}

\item{d}{A dimension of domain. It must be 2 for now}

\item{m}{A size of conditioning sets}

\item{method.locs}{random or grid}

\item{method.modify}{An argument specifying a correction method for the cholesky factorization of a covariance matrix. At \code{NULL} by default.
If correction is \code{NULL}, then the built-in R function \code{chol} is used.
If correction is \code{"qr"}, then the built-in R function \code{qr} is used.
If correction is \code{"diag"}, then \code{C + diag(tol, n)} is used instead of a covariance matrix \code{C}.
Correction methods \code{"type-I"}, \code{"type-II"}, \code{"eigen-I"}, \code{"eigen-II"}, \code{"GMW81"}, and \code{"SE99"} are refered to Fang and O'leary (2008).
Correction method \code{"nearPD"} use a built-in function nearPD() in the R package Matrix.}

\item{pivot}{Logical indicating if pivoting is to be used when factorizing a covariance matrix. At \code{FALSE} by default}

\item{tol}{Numerical tolerance. At \code{.Machine$double.eps} by default}

\item{verbose}{Logical at \code{TRUE} by default. If verbose is \code{TRUE}, then this function prints out all messages}

\item{covmodel}{Covariance function}

\item{...}{Covariance parameters}
}
\value{
list
}
\description{
Conducting simulation on vecchia approximations for (GP, dGP/dx, dGP/dy) with known covariance parameters
}
\examples{
par(mfrow = c(2, 1))

locs <- matrix(runif(10), 5, 2)
covmat <- cov_derivative_matern_2.5_2d(locs = locs, covparms = c(1, 0.1))
fields::image.plot(1 - covmat / max(diag(covmat)), main = "distance matrix with range = 0.1")

locs <- matrix(runif(10), 5, 2)
covmat <- cov_derivative_matern_2.5_2d(locs = locs, covparms = c(1, 4))
fields::image.plot(1 - covmat / max(diag(covmat)), main = "distance matrix with range = 4")

par(mfrow = c(1, 1))

out <- simulate_derivative_knownCovparms(nsim = 1, n = 10^2, d = 2, m = 10, 
                                         method.locs = 'random', 
                                         covmodel = cov_derivative_matern_2.5_2d, 
                                         covparms = c(1, 4), pivot = FALSE, 
                                         method.modify = "eigen-I", tol = 1e-6)

out$kls.average
}
