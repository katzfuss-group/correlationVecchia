% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/bayesian.R
\name{posterior_for_cov_bivariate_expo_latDim}
\alias{posterior_for_cov_bivariate_expo_latDim}
\title{Computing the approximate posterior of the parameters for cov_bivariate_expo_latDim}
\usage{
posterior_for_cov_bivariate_expo_latDim(
  z,
  locs,
  covparms,
  nugget = 0,
  m = 30,
  approx = "cc",
  target = "range",
  N = 100,
  xlim = c(0.05, 0.15),
  sdlog = 0.6
)
}
\arguments{
\item{z}{process}

\item{locs}{locs}

\item{covparms}{covariance parameters}

\item{nugget}{nugget (noise)}

\item{m}{the size of conditioning sets}

\item{approx}{b1, b2, b3, b4, or cc}

\item{target}{range or distance}

\item{N}{the number of grid points}

\item{xlim}{extent of the search}

\item{sdlog}{prior standard deviation of log(parameter)}
}
\value{
list
}
\description{
Computing the approximate posterior of the parameters for cov_bivariate_expo_latDim
}
\examples{
\dontrun{
n               <- 20^2
covparms        <- c(1, 0.1, 0.1)
process         <- generate_gp_space(nsim = 1, n = n, d = 2, p = 2, method.locs = 'random', covmodel = cov_bivariate_expo_latDim, covparms = covparms)

locs            <- process$sim$sim1$locs
locsall         <- rbind(locs$locs1, locs$locs2)

nugget          <- 0.0
z               <- process$sim$sim1$y + nugget * rnorm(2 * n)

par(mfrow = c(1, 2))
fields::quilt.plot(locsall, 1][1:n], locsall[, 2][1:n], z[1:n], main = "component 1")
fields::quilt.plot(locsall[, 1][1:n + n], locsall[, 2][1:n + n], z[1:n + n], main = "component 2")
par(mfrow = c(1, 1))

out.range       <- posterior_for_cov_bivariate_expo_latDim(z = z, locs = locs, covparms = covparms, target = "range", xlim = c(0.065, 0.14))
out.distance    <- posterior_for_cov_bivariate_expo_latDim(z = z, locs = locs, covparms = covparms, target = "distance", xlim = c(0.065, 0.14))

par(mfrow = c(1, 2))
matplot(out.range$alpha, out.range$post.norm, type = 'l', xlim = range(out.range$alpha), lty = 1, lwd = 2, xlab = 'range', ylab = 'density', main = "posterior distribution for range parameter")
legend('topright', c('exact', 'approx'), col = 1:2, lty = 1, lwd = 2)

matplot(out.distance$alpha, out.distance$post.norm, type = 'l', xlim = range(out.distance$alpha), lty = 1, lwd = 2, xlab = 'distance in latent dimension', ylab = 'density', main = "posterior distribution for distance in latent dimension")
legend('topright', c('exact', 'approx'), col = 1:2, lty = 1, lwd = 2)
par(mfrow = c(1, 1))
}
}
